use super::WriteBackError;
use super::properties::PropertyFile;
use crate::change_descriptors::ModelChange;
use std::path::Path;

/// A trait implemented by changes that can be executed by the writeback layer.
///
/// This module centralizes executable change implementations. Checks still
/// produce lightweight change descriptors (in `crate::check`), and those are
/// converted into fully-owned, executable operations here at writeback time.
pub trait ExecutableChange {
    /// Apply this change. Implementations should perform any in-memory
    /// mutations against `root` and any filesystem effects using `project_root`.
    fn apply_with_fs(
        &self,
        root: &mut PropertyFile,
        project_root: &Path,
    ) -> Result<Vec<String>, WriteBackError>;
}

impl ExecutableChange for ModelChange {
    fn apply_with_fs(
        &self,
        root: &mut PropertyFile,
        project_root: &Path,
    ) -> Result<Vec<String>, WriteBackError> {
        match self {
            ModelChange::MovePropertiesFile {
                patch_path,
                new_path,
                ..
            } => {
                let patch = patch_path
                    .clone()
                    .ok_or_else(|| WriteBackError::PatchPathMissing {
                        model_id: "".to_string(),
                    })?;
                let src = if patch.is_absolute() {
                    patch.clone()
                } else {
                    project_root.join(&patch)
                };
                let dst = if new_path.is_absolute() {
                    new_path.clone()
                } else {
                    project_root.join(new_path)
                };
                if let Some(parent) = dst.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                std::fs::rename(&src, &dst)?;
                Ok(Vec::new())
            }
            ModelChange::ChangePropertiesFile {
                model_name,
                property,
                ..
            } => {
                let Some(prop) = property else {
                    return Ok(Vec::new());
                };

                if let Some(existing) = root.find_model_mut(model_name) {
                    existing.merge(prop);
                } else {
                    let mut new_prop = prop.clone();
                    if new_prop.name.is_none() {
                        new_prop.name = Some(model_name.clone());
                    }
                    root.models.get_or_insert_with(Vec::new).push(new_prop);
                }

                // Return synthetic entry to signal the YAML should be rewritten.
                Ok(vec![format!("@model:{model_name}")])
            }
            ModelChange::GeneratePropertiesFile { .. } => {
                // No additional mutation required: the properties file was
                // already generated by the check phase. Nothing to merge into
                // the in-memory `PropertyFile` here.
                Ok(Vec::new())
            }
            ModelChange::MoveModelFile {
                patch_path,
                new_path,
                ..
            } => {
                let patch = patch_path
                    .clone()
                    .ok_or_else(|| WriteBackError::PatchPathMissing {
                        model_id: "".to_string(),
                    })?;
                let src = if patch.is_absolute() {
                    patch.clone()
                } else {
                    project_root.join(&patch)
                };
                let dst = if new_path.is_absolute() {
                    new_path.clone()
                } else {
                    project_root.join(new_path)
                };
                if let Some(parent) = dst.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                std::fs::rename(&src, &dst)?;
                Ok(Vec::new())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::writeback::properties::{ColumnProperty, ModelProperty, PropertyFile};
    use std::collections::BTreeMap;

    #[test]
    fn change_properties_file_merges_column_updates() {
        let mut root = PropertyFile {
            models: Some(Vec::new()),
            sources: None,
            extras: BTreeMap::new(),
        };
        root.models.as_mut().unwrap().push(ModelProperty {
            name: Some("test_model".to_string()),
            description: None,
            columns: vec![ColumnProperty {
                name: "col_a".to_string(),
                description: Some("old".to_string()),
                extras: BTreeMap::new(),
            }],
            extras: BTreeMap::new(),
        });

        let change = ModelChange::ChangePropertiesFile {
            model_id: "model.test.test_model".to_string(),
            model_name: "test_model".to_string(),
            patch_path: None,
            property: Some(ModelProperty {
                name: Some("test_model".to_string()),
                description: None,
                columns: vec![ColumnProperty {
                    name: "col_a".to_string(),
                    description: Some("new".to_string()),
                    extras: BTreeMap::new(),
                }],
                extras: BTreeMap::new(),
            }),
        };

        let updated = change
            .apply_with_fs(&mut root, std::path::Path::new("/"))
            .expect("apply should succeed");

        assert_eq!(updated, vec!["@model:test_model".to_string()]);
        let m = root.find_model_mut("test_model").expect("model exists");
        assert_eq!(
            m.columns
                .iter()
                .find(|c| c.name == "col_a")
                .unwrap()
                .description
                .as_deref(),
            Some("new")
        );
    }

    #[test]
    fn model_change_moves_patch_file() {
        use std::fs;
        use std::path::PathBuf;
        use tempfile::tempdir;

        let dir = tempdir().expect("tempdir");
        let src = dir.path().join("models.yml");
        fs::write(&src, "models: []").expect("write src");

        let change = ModelChange::MovePropertiesFile {
            model_id: "model.test.m".to_string(),
            model_name: "m".to_string(),
            patch_path: Some(PathBuf::from("models.yml")),
            new_path: PathBuf::from("moved/models.yml"),
        };

        // Apply the model change with project_root set to the temp dir
        let mut root = PropertyFile {
            models: Some(Vec::new()),
            sources: None,
            extras: BTreeMap::new(),
        };
        change.apply_with_fs(&mut root, dir.path()).expect("apply");

        let dst = dir.path().join("moved/models.yml");
        assert!(dst.exists(), "destination file should exist");
        // source should no longer exist
        assert!(!src.exists(), "source file should have been moved");
    }
}
